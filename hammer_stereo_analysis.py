# -*- coding: utf-8 -*-
"""Stereo_Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rITmrNbIYxTdlzCZj6NGWKO8ryG4EV5P
"""

!pip install ezc3d

import os
import re
import ezc3d
import numpy as np
import matplotlib.pyplot as plt
import pickle
import csv
from collections import defaultdict
from google.colab import drive

drive.mount('/content/drive')

# -----------------------------
# CONFIGURATION
# -----------------------------

base_dir = '/content/drive/MyDrive/Hammer_Data'

data_cache_file = '/content/drive/MyDrive/Hammer_Data/DATA_cache.pkl'

cut_data_cache_file = '/content/drive/MyDrive/Hammer_Data/DATA_CUT_cache.pkl'

shoe_map = {"Campain": "WA", "Vibram": "FF"}
trial_types = ["4gr_spost_osc", "ferma_osc"]
subjects = [f"SUB{str(i).zfill(3)}" for i in range(1, 13)]
platform_names = [ "AMTI1", "AMTI2"]

subject_info = {
    'SUB001': {'mass': 135, 'gender': 0}, 'SUB002': {'mass': 85, 'gender': 1},
    'SUB003': {'mass': 93, 'gender': 0}, 'SUB004': {'mass': 89, 'gender': 0},
    'SUB005': {'mass': 75, 'gender': 1}, 'SUB006': {'mass': 75, 'gender': 1},
    'SUB007': {'mass': 60, 'gender': 1}, 'SUB008': {'mass': 94, 'gender': 0},
    'SUB009': {'mass': 73, 'gender': 1}, 'SUB010': {'mass': 93, 'gender': 1},
    'SUB011': {'mass': 69, 'gender': 1}, 'SUB012': {'mass': 73, 'gender': 1}
}

# -----------------------------
# SAVE FUNCTION
# -----------------------------

def save_data_structures(DATA, DATA_CUT, base_dir):
    with open(os.path.join(base_dir, "DATA_cache.pkl"), 'wb') as f:
        pickle.dump(DATA, f)
    with open(os.path.join(base_dir, "DATA_CUT_cache.pkl"), 'wb') as f:
        pickle.dump(DATA_CUT, f)
    print("Saved DATA and DATA_CUT to disk.")

# -----------------------------
# LOAD DATA OR FROM C3D
# -----------------------------

def nested_dict():
    return defaultdict(nested_dict)

choice = input("Load from cache (c) or from c3d files (f)? [c/f]: ").strip().lower()
if choice == 'f':
    DATA = nested_dict()
    for shoe_folder, shoe_type in shoe_map.items():
        shoe_path = os.path.join(base_dir, shoe_folder)
        for subj in subjects:
            subj_path = os.path.join(shoe_path, subj)
            if not os.path.isdir(subj_path):
                continue
            for file in os.listdir(subj_path):
                if file.endswith(".c3d"):
                    file_path = os.path.join(subj_path, file)
                    trial_found = None
                    for trial in trial_types:
                        if re.search(trial, file, re.IGNORECASE):
                            trial_found = trial
                            break
                    if trial_found is None:
                        print(f"Skipping file (unrecognized trial): {file}")
                        continue
                    c3d = ezc3d.c3d(file_path)
                    fps_marker = c3d['header']['points']['frame_rate']
                    fps_analog = c3d['header']['analogs']['frame_rate']
                    markers = c3d['data']['points']
                    try:
                        marker_names = c3d['parameters']['POINT']['LABELS']['value']
                    except KeyError:
                        marker_names = []
                        print(f"Marker labels not found in: {file}")
                    forces = c3d['data']['analogs'][0]
                    platform_dict = {}
                    channels_per_platform = 6  # Fx, Fy, Fz, Mx, My, Mz
                    force_only_channels = 3    # Only Fx, Fy, Fz

                    for i, platform in enumerate(platform_names):
                        start = i * channels_per_platform
                        end = start + force_only_channels  # pick only Fx, Fy, Fz
                        if end <= forces.shape[0]:
                            platform_dict[platform] = forces[start:end, :]
                        else:
                            print(f"‚ö†Ô∏è Canali insufficienti per {platform} nel file {file}")

                    trial_entry = {
                        'filename': file,
                        'mkr': markers,
                        'marker_names': marker_names,
                        'force': platform_dict,
                        'fps_marker': fps_marker,
                        'fps_analog': fps_analog
                    }
                    DATA[subj][shoe_type][trial_found].setdefault('reps', []).append(trial_entry)
                    print(f"‚úîÔ∏è Caricato {file} come {subj} - {shoe_type} - {trial_found}")
    def convert(d):
        if isinstance(d, defaultdict):
            return {k: convert(v) for k, v in d.items()}
        return d
    with open(data_cache_file, 'wb') as f:
        pickle.dump(convert(DATA), f)
    print("Loaded and saved data from c3d files.")
else:
    with open(data_cache_file, 'rb') as f:
        DATA = pickle.load(f)
    print("Loaded DATA from cache.")

if os.path.exists(cut_data_cache_file):
    with open(cut_data_cache_file, 'rb') as f:
        DATA_CUT = pickle.load(f)
        print("Loaded DATA_CUT from cache.")
else:
    DATA_CUT = None
    print("DATA_CUT file not found. You might need to generate it.")

#########################################################################################################
# -----------------------------
# TAGLIO SINCRONIZZATO - ONSET E OFFSET
# -----------------------------

def detect_onset_offset(velocity, velocity_threshold=0.2, pre_peak=200, post_peak=200):
    velocity = np.asarray(velocity).flatten()
    dv = np.gradient(velocity)

    # ONSET
    onset = 0
    for i in range(1, len(velocity)):
        if velocity[i] > velocity_threshold and dv[i] > 0.01:
            if np.max(velocity[i:i + 100]) > 12:
                onset = i
                break

    # OFFSET
    peak_idx = np.argmax(velocity)
    offset_start = min(len(velocity) - 1, peak_idx + post_peak)
    for j in range(offset_start, len(velocity)):
        if velocity[j] < velocity_threshold:
            offset = j
            break
    else:
        offset = len(velocity) - 1

    return onset, offset
############################################################################################################
# -----------------------------
# MANUAL CUT REVIEW FUNCTION
# -----------------------------
def manual_cut_review(rep, subj, shoe, trial):
    # Se gi√† eseguito, salta
    if 'cut_onset' in rep and 'cut_offset' in rep:
        print(f"‚úÖ Cut already exists for {subj} - {shoe} - {trial}")
        return

    # Calcolo velocit√† se assente
    if 'hammer_vel_global' not in rep or rep['hammer_vel_global'] is None:
        mkr = rep['mkr']
        names = rep['marker_names']
        names_lower = [n.lower() for n in names]

        try:
            idxs = [names_lower.index(m) for m in ['hammer2', 'hammer3', 'hammer4']]
            hammer_xyz = mkr[0:3, idxs, :]
            hammer_centroid = np.mean(hammer_xyz, axis=1)
            rep['HAMMER'] = hammer_centroid
        except ValueError:
            print(f"‚ö†Ô∏è HAMMER markers missing in: {rep['filename']}")
            rep['HAMMER'] = None

        if rep['HAMMER'] is not None:
            hammer_vel_global = np.diff(rep['HAMMER'], axis=1, prepend=rep['HAMMER'][:, :1])
            rep['hammer_vel_global'] = hammer_vel_global
        else:
            rep['hammer_vel_global'] = None

    v = rep.get('hammer_vel_global')
    if v is None:
        print(f"No velocity data for {subj} - {shoe} - {trial}")
        return

    mag = np.linalg.norm(v, axis=0)
    onset, offset = detect_onset_offset(mag)

    plt.figure(figsize=(12, 5))
    plt.plot(mag, label='Hammer Velocity Magnitude')
    plt.axvline(onset, color='g', linestyle='--', label='Detected Onset')
    plt.axvline(offset, color='r', linestyle='--', label='Detected Offset')
    plt.title(f"{subj} - {shoe} - {trial}")
    plt.xlabel("Frame")
    plt.ylabel("Velocity [m/s]")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    rep['cut_onset'] = onset
    rep['cut_offset'] = offset
    rep['hammer_vel_global_cut'] = v[:, onset:offset]
    rep['mkr_cut'] = rep['mkr'][:, :, onset:offset]
    onset_force = int(rep.get('cut_onset') / rep.get('fps_marker') * rep.get('fps_analog'))
    offset_force = int(rep.get('cut_offset') / rep.get('fps_marker') * rep.get('fps_analog'))
    if 'force_cut' not in rep and 'force' in rep:
        rep['force_cut'] = {
            k: rep['force'][k][:, onset_force:offset_force] for k in rep['force']
            if isinstance(rep['force'][k], np.ndarray) and rep['force'][k].ndim == 2
            }

# -----------------------------
# REVIEW ALL TRIALS WRAPPER
# -----------------------------
def review_all_trials(DATA, cut_data_cache_file=None):
    for subj in DATA:
        for shoe in DATA[subj]:
            for trial in DATA[subj][shoe]:
                # ‚úÖ Usa get('reps', []) per maggiore robustezza
                reps = DATA[subj][shoe][trial].get('reps', [])
                for idx, rep in enumerate(reps):
                    print(f"\n‚ñ∂Ô∏è Reviewing: {subj} - {shoe} - {trial} - rep {idx+1}")
                    try:
                        manual_cut_review(rep, subj=subj, shoe=shoe, trial=trial)
                    except Exception as e:
                        print(f"‚ùå Error processing {subj} - {shoe} - {trial} rep {idx+1}: {e}")

    if cut_data_cache_file:
        with open(cut_data_cache_file, 'wb') as f:
            pickle.dump(DATA, f)
        print("üíæ DATA salvato con i tagli in", cut_data_cache_file)

# -----------------------------
# DATA ANALYSIS WRAPPER
# -----------------------------
def compute_data_analysis(DATA,cut_data_cache_file):
    for subj in DATA:
        for shoe in DATA[subj]:
            for trial in DATA[subj][shoe]:
                for rep in DATA[subj][shoe][trial]['reps']:
                    v = rep.get('hammer_vel_global')
                    if v is None:
                        continue
                    mag = np.linalg.norm(v, axis=0)
                    onset = rep.get('cut_onset')
                    offset = rep.get('cut_offset')
                    if onset is None or offset is None:
                        onset, offset = detect_onset_offset(mag)
                        rep['cut_onset'] = onset
                        rep['cut_offset'] = offset
                    onset_force = int(rep.get('cut_onset') / rep.get('fps_marker') * rep.get('fps_analog'))
                    offset_force = int(rep.get('cut_offset') / rep.get('fps_marker') * rep.get('fps_analog'))
                    rep['cut_onset_force'] = onset_force
                    rep['cut_offset_force'] = offset_force
                    fps_mkr2force = 1 / rep.get('fps_marker') * rep.get('fps_analog')
                    rep['cut_onset_force'] = onset_force
                    rep['cut_offset_force'] = offset_force
                    rep['fps_mkr2force'] = fps_mkr2force
                    rep['hammer_vel_global_cut'] = v[:, onset:offset]
                    rep['mkr_cut'] = rep['mkr'][:, :, onset:offset]
                    if 'force_cut' not in rep and 'force' in rep:
                        rep['force_cut'] = {
                        k: rep['force'][k][:, onset_force:offset_force] for k in rep['force']
                        if isinstance(rep['force'][k], np.ndarray) and rep['force'][k].ndim == 2
                    }

    with open(cut_data_cache_file, 'wb') as f:
        pickle.dump(DATA, f)

    print("‚úÖ Dati analizzati e tagliati con successo.")

import os
import pickle
import numpy as np
from collections import defaultdict

def generate_DATA_CUT(DATA, save_path=None):
    def nested_dict():
        return defaultdict(nested_dict)

    DATA_CUT = nested_dict()

    for subj in DATA:
        for shoe in DATA[subj]:
            for trial in DATA[subj][shoe]:
                for idx, rep in enumerate(DATA[subj][shoe][trial].get("reps", [])):
                    onset = rep.get("cut_onset")
                    offset = rep.get("cut_offset")
                    onset_force = int(rep.get('cut_onset') / rep.get('fps_marker') * rep.get('fps_analog'))
                    offset_force = int(rep.get('cut_offset') / rep.get('fps_marker') * rep.get('fps_analog'))
                    rep['cut_onset_force'] = onset_force
                    rep['cut_offset_force'] = offset_force
                    if onset is None or offset is None:
                        continue

                    # Marker cut
                    mkr = rep.get("mkr")
                    mkr_cut = mkr[:, :, onset:offset] if mkr is not None else None

                    # Velocity cut
                    hammer_vel_global = rep.get("hammer_vel_global", np.zeros((3, 1)))
                    hammer_vel_global_cut = hammer_vel_global[:, onset:offset]

                    # Slice force data
                    force_cut = {}
                    try:
                        force = rep.get("force", {})
                        for k, v in force.items():
                            if isinstance(v, np.ndarray):
                                force_cut[k] = v[:,onset_force:offset_force]  # ‚úÖ Usa slicing 1D
                    except Exception:
                        force_cut = {}

                    # Create cut entry
                    entry = {
                        "filename": rep.get("filename", ""),
                        "cut_onset": onset,
                        "cut_offset": offset,
                        "marker_names": rep.get("marker_names", []),
                        "mkr": mkr,
                        "mkr_cut": mkr_cut,
                        "hammer_vel_global_cut": hammer_vel_global_cut,
                        "force_cut": force_cut
                    }

                    DATA_CUT[subj][shoe][trial].setdefault("reps", []).append(entry)

    # Convert nested dict
    def convert(d):
        if isinstance(d, defaultdict):
            return {k: convert(v) for k, v in d.items()}
        return d

    converted = convert(DATA_CUT)

    if save_path:
        try:
            with open(save_path, 'wb') as f:
                pickle.dump(converted, f)
            print(f"‚úÖ DATA_CUT saved to: {save_path}")
        except Exception as e:
            print(f"‚ùå Failed to save DATA_CUT: {e}")

    return converted

# -----------------------------
# APPLY MANUAL CUT CORRECTIONS
# -----------------------------

def apply_manual_corrections(DATA, save_path):

    corrections = [
        {'subj': 'SUB006', 'shoe': 'FF', 'trial': '4gr_spost_osc', 'rep': 0, 'onset': 250, 'offset': 1650},
        {'subj': 'SUB007', 'shoe': 'WA', 'trial': '4gr_spost_osc', 'rep': 0, 'onset': 850, 'offset': 2180},
        {'subj': 'SUB007', 'shoe': 'WA', 'trial': 'ferma_osc', 'rep': 1, 'onset': 525, 'offset': 1825},
        {'subj': 'SUB007', 'shoe': 'FF', 'trial': '4gr_spost_osc', 'rep': 0, 'onset': 575, 'offset': 1930},
        {'subj': 'SUB007', 'shoe': 'FF', 'trial': '4gr_spost_osc', 'rep': 2, 'onset': 290, 'offset': 1590},
        {'subj': 'SUB007', 'shoe': 'FF', 'trial': 'ferma_osc', 'rep': 1, 'onset': 470, 'offset': 1750},
        {'subj': 'SUB007', 'shoe': 'FF', 'trial': 'ferma_osc', 'rep': 2, 'onset': 440, 'offset': 1700},
        {'subj': 'SUB008', 'shoe': 'WA', 'trial': '4gr_spost_osc', 'rep': 0, 'onset': 5450, 'offset': 6750},
        {'subj': 'SUB008', 'shoe': 'WA', 'trial': '4gr_spost_osc', 'rep': 1, 'onset': 1740, 'offset': 3100},
        {'subj': 'SUB008', 'shoe': 'FF', 'trial': 'ferma_osc', 'rep': 2, 'onset': 3705, 'offset': 5170},
        {'subj': 'SUB009', 'shoe': 'FF', 'trial': 'ferma_osc', 'rep': 0, 'onset': 6500, 'offset': 8000},
    ]

    for corr in corrections:
        try:
            rep = DATA[corr['subj']][corr['shoe']][corr['trial']]['reps'][corr['rep']]
            v = rep['hammer_vel_global']
            onset = corr['onset']
            offset = corr['offset']
            rep['cut_onset'] = onset
            rep['cut_offset'] = offset
            onset_force = int(rep.get('cut_onset') / rep.get('fps_marker') * rep.get('fps_analog'))
            offset_force = int(rep.get('cut_offset') / rep.get('fps_marker') * rep.get('fps_analog'))
            fps_mkr2force = 1 / rep.get('fps_marker') * rep.get('fps_analog')
            rep['cut_onset_force'] = onset_force
            rep['cut_offset_force'] = offset_force
            rep['fps_mkr2force'] = fps_mkr2force
            rep['hammer_vel_global_cut'] = v[:, onset:offset]
            rep['mkr_cut'] = rep['mkr'][:, :, onset:offset]
            rep['force_cut'] = {k: rep['force'][k][:,onset_force:offset_force] for k in rep['force']}
            print(f"‚úÖ Updated cut for {corr['subj']} - {corr['shoe']} - {corr['trial']} - rep {corr['rep']+1}")
        except Exception as e:
            print(f"‚ùå Failed to update cut for {corr['subj']} - {corr['shoe']} - {corr['trial']} - rep {corr['rep']+1}: {e}")

    with open(save_path, 'wb') as f:
        pickle.dump(DATA, f)
    print("üíæ DATA updated and saved with manual corrections.")

review_all_trials(DATA, cut_data_cache_file)

apply_manual_corrections(DATA,cut_data_cache_file)

compute_data_analysis(DATA,cut_data_cache_file)

DATA_CUT = generate_DATA_CUT(DATA, save_path=cut_data_cache_file)

import numpy as np
import matplotlib.pyplot as plt

def compute_instants(rep):
    markers = rep['mkr_cut']  # shape: 3 x N_markers x N_frames
    marker_names = rep['marker_names']
    n_frames = markers.shape[2]

    # Helper function to get marker index
    def get_marker_index(name):
        try:
            return marker_names.index(name)
        except ValueError:
            raise ValueError(f"Marker {name} not found in marker_names.")

    def find_peaks(arr):

        peaks = []
        for i in range(len(arr) - 1):
            if arr[i] > arr[i+1] and arr[i] > arr[i-1]:
                peaks.append(i)
            elif arr[i-1] is None:
                i+1
        return np.array(peaks)

    def ensure_list(v):
        """Convert a scalar or None to a list; leave lists/arrays unchanged."""
        if v is None:
            return []
        if isinstance(v, (list, np.ndarray)):
            return list(v)
        return [v]

    mkr = rep['mkr_cut']
    names = rep['marker_names']

    names_lower = [n.lower() for n in names]

    # --- HAMMER centroid ---

    idxs = [names_lower.index(m) for m in ['hammer2', 'hammer3', 'hammer4']]
    hammer_xyz = mkr[0:3, idxs, :]
    hammer_centroid = np.mean(hammer_xyz, axis=1)

    # Get marker indices
    #LANK_idx = names.index("LANK")
    LHEE_idx = names.index("LHEE")
    LTOE_idx = names.index("LTOE")
    LFMH_idx = names.index("LFMH")
    LVMH_idx = names.index("LVMH")

    #RANK_idx = names.index("RANK")
    RHEE_idx = names.index("RHEE")
    RTOE_idx = names.index("RTOE")
    RFMH_idx = names.index("RFMH")
    RVMH_idx = names.index("RVMH")

    LSHO_idx = names.index("LSHO")
    RSHO_idx = names.index("RSHO")

    # Extract marker positions
    #LANK = mkr[:, LANK_idx, :]
    LHEE = mkr[:, LHEE_idx, :]
    LTOE = mkr[:, LTOE_idx, :]
    LFMH = mkr[:, LFMH_idx, :]
    LVMH = mkr[:, LVMH_idx, :]

    hammer_pos = hammer_centroid  # shape: 3 x N_frames
    #RANK = mkr[:, RANK_idx, :]
    RHEE = mkr[:, RHEE_idx, :]
    RTOE = mkr[:, RTOE_idx, :]
    RFMH = mkr[:, RFMH_idx, :]
    RVMH = mkr[:, RVMH_idx, :]

    LSHO = mkr[:, LSHO_idx, :]
    RSHO = mkr[:, RSHO_idx, :]


    # Converts instants
    fps_mkr2force = 5;
    instants = {}

    # Instant 1: Allineamento tra asse piedi e vettore spalle-martello (angolo vicino a 180¬∞)

    # Posizione martello (gi√† in rep['HAMMER'])
    hammer_xy = hammer_pos[:2, :]  # shape: (2, n_frames)

    # rotation matrix for XY plane
    R = np.array([[-1, 0],
                  [0, -1]])

    # apply rotation only to X and Y
    hammer_xy = R @ hammer_pos[:2, :]   # shape (2, n_frames)
    left_shoulder = R @ LSHO[:2, :]
    right_shoulder = R @ RSHO[:2, :]
    shoulders_center = 0.5 * (left_shoulder + right_shoulder)

    hammer_pos = np.vstack([hammer_xy, hammer_pos[2, :]])  # shape still (3, n_frames)


    # Vettore dalle spalle al martello
    shoulder_hammer = hammer_xy - shoulders_center  # shape: (2, n_frames)

    # shoulder_hammer_xy: shape (2, N)
    hx, hy = shoulder_hammer  # hx = X, hy = Y

    # Correct order for arctan2: np.arctan2(Y, X)
    angle_deg_series = np.degrees(np.arctan2(hy, hx))  # signed angles -180 -> 180

    # Make angles in 0-360 range for convenience
    angle_deg_series = (angle_deg_series + 360) % 360

    # Targets
    targets = [0, 180, 270]
    instants = {}

    # Find frames closest to target angles

    candidates = find_peaks(hx)

    I1 = candidates[-1]
    I2 = I1 + np.argmin(np.abs(angle_deg_series[I1:] - 180))  # closest to 180¬∞
    I3 = I2 + np.argmin(np.abs(angle_deg_series[I2:] - 270))  # closest to 270¬∞

    if angle_deg_series[I2] < 175 or angle_deg_series[I2] > 185 or angle_deg_series[I3] < 265 or angle_deg_series[I3] > 275:

      I1 = candidates[-2]
      I2 = I1 + np.argmin(np.abs(angle_deg_series[I1:candidates[-1]] - 180))  # closest to 180¬∞
      I3 = I2 + np.argmin(np.abs(angle_deg_series[I2:candidates[-1]] - 270))  # closest to 270¬∞

    print("I1:", I1, "angle:", angle_deg_series[I1])
    instants['I1'] = I1
    instants['I1_f'] = I1 * fps_mkr2force
    print("I2:", I2, "angle:", angle_deg_series[I2])
    instants['I2'] = I2
    instants['I2_f'] = I2 * fps_mkr2force
    print("I3:", I3, "angle:", angle_deg_series[I3])
    instants['I3'] = I3
    instants['I3_f'] = I3 * fps_mkr2force

    # Instant 4: Posizione verticale minima del martello tra I2 e I3
    start_idx = instants['I1'] + 1

    if candidates[-1] != instants['I1'] :

        end_idx = candidates[-1]

    else:

        end_idx = hammer_xy.shape[1] - 1

    z_pos_between = hammer_pos[2, start_idx:end_idx]

    if z_pos_between.size > 0:
        relative_min_idx = np.argmin(z_pos_between)
        absolute_min_idx = start_idx + relative_min_idx
        instants['I4'] = absolute_min_idx
        instants['I4_f'] = absolute_min_idx * fps_mkr2force

    else:
        # fallback: global minimum if no data in range
        instants['I4'] = 0
        instants['I4_f'] = 0


    # Instant 5: Sollevamento del piede destro

    z_pos_front= RTOE[2, :]

    if z_pos_front.size > 0:
        above_threshold = np.where(z_pos_front > 87)[0]  # threshold

        if above_threshold.size > 0:
            # find the first frame of each continuous sequence
            first_frames = []
            for i, frame in enumerate(above_threshold):
                if i == 0:
                    first_frames.append(frame)
                else:
                    if frame != above_threshold[i - 1] + 1:
                        first_frames.append(frame)

            instants['I5'] = first_frames
            instants['I5_f'] = [idx * fps_mkr2force for idx in first_frames]
        else:
            print(f"‚ö†Ô∏è No frame above 87 mm found in {rep.get('filename', 'unknown')}")
            instants['I5'] = 0
            instants['I5_f'] = 0
    else:
        instants['I5'] = 0
        instants['I5_f'] = 0

    rep['instants'] = instants

    # Base plot: trajectory + first 4 instants
    plt.figure(figsize=(10,6))
    plt.plot(hammer_pos[0, :], hammer_pos[1, :], label='Traiettoria Hammer')

    colors = ['red', 'green', 'blue', 'orange']
    keys = ["I1","I2","I3","I4"]

    for i, key in enumerate(keys):
        idxs = ensure_list(instants.get(key, []))  # wrap single int in list if needed
        valid = [j for j in idxs if 0 < j < hammer_pos.shape[1]]
        if valid:
            plt.scatter(hammer_pos[0, valid], hammer_pos[1, valid],
                    color=colors[i], label=key)

    # Overlay multiple I5 points
    I5_list = ensure_list(instants.get('I5', []))
    valid_I5 = [j for j in I5_list if 0 < j < hammer_pos.shape[1]]
    if valid_I5:
        plt.scatter(hammer_pos[0, valid_I5], hammer_pos[1, valid_I5],
                color='purple', label='I5 (all turns)', zorder=5)

    plt.legend()
    plt.title("Istanti")
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.grid(True)
    plt.show()

# Additional variable computation added to compute_variables()
def compute_additional_variables(rep):


    def ensure_list(v):
        if v is None:
            return []
        if isinstance(v, (list, np.ndarray)):
            return list(v)
        return [v]

    instants = rep.get('instants')
    if not instants:
        print(f"‚ö†Ô∏è Istanti mancanti per {rep.get('filename', 'unknown')}")
        return

    I1 = instants['I1']
    I2 = instants['I2']
    I3 = instants['I3']
    I4 = instants['I4']
    I5 = instants['I5']
    I1_f = instants['I1_f']
    I2_f = instants['I2_f']
    I3_f = instants['I3_f']
    I4_f = instants['I4_f']
    I5_f = instants['I5_f']

    # Forze sulle piattaforme
    for platform in ["AMTI1", "AMTI2"]:
        force = rep.get('force_cut', {}).get(platform)

        if not isinstance(force, np.ndarray):
            print(f"‚ö†Ô∏è Dato mancante o non array per {platform} in {rep.get('filename', 'unknown')}")
            continue

        if force.shape[0] < 3:
            print(f"‚ö†Ô∏è Troppi pochi canali per {platform} in {rep.get('filename', 'unknown')} ‚Üí shape: {force.shape}")
            continue

        if force.ndim != 2:
            print(f"‚ö†Ô∏è Formato non valido per {platform} in {rep.get('filename', 'unknown')} ‚Üí ndim: {force.ndim}")
            continue

        for i5 in ensure_list(I5):
            if i5 >= force.shape[1]:
                print(f"‚ö†Ô∏è I5={i5} out of bounds per {platform} in {rep.get('filename', 'unknown')} ‚Üí max={force.shape[1]}")
                continue

        try:
            # Salva solo Fx, Fy, Fz
            rep[f'{platform}_force_interval'] = [force[0:3, I1:i5+1] for i5 in ensure_list(I5)]
            rep[f'{platform}_force_instants'] = {
                'I1': force[0:3, I1_f],
                'I2': force[0:3, I2_f],
                'I3': force[0:3, I3_f],
                'I4': force[0:3, I4_f],
                'I5': [force[0:3, idx] for idx in ensure_list(I5_f)]
            }
        except Exception as e:
            print(f"‚ùå Errore scrittura forze per {platform} in {rep.get('filename', 'unknown')}: {e}")

    # Velocit√† tangenziale del martello
    vel = rep.get('hammer_vel_COM')
    if isinstance(vel, np.ndarray) and vel.ndim == 2 and vel.shape[0] == 3:
        try:
            rep['hammer_vel_COM_interval'] = [vel[:, I1:i5+1] for i5 in ensure_list(I5)]
            rep['hammer_vel_COM_instants'] = {
                'I1': vel[:, I1], 'I2': vel[:, I2], 'I3': vel[:, I3], 'I4': vel[:, I4], 'I5': [vel[:, idx] for idx in ensure_list(I5)]
            }
        except IndexError:
            print(f"‚ö†Ô∏è Indici fuori range per hammer_vel_COM in {rep.get('filename', 'unknown')}")

    # Velocit√† angolare del martello
    omega = rep.get('angular_velocity')
    if isinstance(omega, np.ndarray) and omega.ndim == 2 and omega.shape[0] == 3:
        try:
            rep['angular_velocity_interval'] = [omega[:, I1:i5+1] for i5 in ensure_list(I5)]
            rep['angular_velocity_instants'] = {
                'I1': omega[:, I1], 'I2': omega[:, I2], 'I3': omega[:, I3], 'I4': omega[:, I4], 'I5': [omega[:, idx] for idx in ensure_list(I5)]
            }
        except IndexError:
            print(f"‚ö†Ô∏è Indici fuori range per angular_velocity in {rep.get('filename', 'unknown')}")


    # Forza centrifuga esercitata dal martello
    forcec = rep.get('centrifugal_force')
    if isinstance(forcec, np.ndarray) and forcec.ndim == 2 and forcec.shape[0] == 3:
        try:
            rep['centrifugal_force_interval'] = [forcec[:, I1:i5+1] for i5 in ensure_list(I5)]
            rep['centrifugal_force_instants'] = {
                'I1': forcec[:, I1], 'I2': forcec[:, I2], 'I3': forcec[:, I3], 'I4': forcec[:, I4], 'I5': [forcec[:, idx] for idx in ensure_list(I5)]
            }
        except IndexError:
            print(f"‚ö†Ô∏è Indici fuori range per centrifugal_force in {rep.get('filename', 'unknown')}")


    # Planta-dorsiflessione della caviglia sinistra
    if rep.get('mkr_cut') is not None and 'LAnkleAngles' in rep.get('marker_names', []):
        try:
            idx = rep['marker_names'].index('LAnkleAngles')
            lank = rep['mkr_cut'][0:3, idx, :]
            rep['LAnkleAngles_instants'] = {
                'I1': lank[1, I1], 'I2': lank[1, I2], 'I3': lank[1, I3],'I4': lank[1, I4], 'I5': [lank[:, idx] for idx in ensure_list(I5)]
            }
        except Exception as e:
            print(f"‚ö†Ô∏è Problema con LAnkleAngles in {rep.get('filename', 'unknown')}: {e}")

    # Planta-dorsiflessione della caviglia sinistra
    if rep.get('mkr_cut') is not None and 'RAnkleAngles' in rep.get('marker_names', []):
        try:
            idx = rep['marker_names'].index('RAnkleAngles')
            rank = rep['mkr_cut'][0:3, idx, :]
            rep['RAnkleAngles_instants'] = {
               'I1': rank[1, I1], 'I2': rank[1, I2], 'I3': rank[1, I3], 'I4': rank[1, I4], 'I5': [rank[:, idx] for idx in ensure_list(I5)]
            }
        except Exception as e:
            print(f"‚ö†Ô∏è Problema con RAnkleAngles in {rep.get('filename', 'unknown')}: {e}")


    # Angolo tra anche e petto (XY, come segnale angolare 1D)
    if rep.get('hip_chest_angle_deg') is not None:
        angle = rep['hip_chest_angle_deg']
        if isinstance(angle, np.ndarray) and angle.ndim == 1:
            try:
                rep['hip_chest_angle_instants'] = {
                    'I1': angle[I1], 'I2': angle[I2], 'I3': angle[I3], 'I4': angle[I4], 'I5': [angle[idx] for idx in ensure_list(I5)]
                }
            except Exception as e:
                print(f"‚ö†Ô∏è Problema con hip_chest_angle_deg in {rep.get('filename', 'unknown')}: {e}")



    # Raggio istantaneo di rotazione (vettore 3D)
    if rep.get('radius_rotation') is not None:
        radius = rep['radius_rotation']
        if isinstance(radius, np.ndarray) and radius.ndim == 2 and radius.shape[0] == 3:
            try:
                rep['radius_rotation_instants'] = {
                    'I1': radius[:, I1], 'I2': radius[:, I2], 'I3': radius[:, I3], 'I4': radius[:, I4], 'I5': [radius[:, idx] for idx in ensure_list(I5)]
                }
            except Exception as e:
                print(f"‚ö†Ô∏è Problema con radius_rotation in {rep.get('filename', 'unknown')}: {e}")


     # Centro di massa del martello (vettore 3D)
    if rep.get('hammer_COM') is not None:
        hcom = rep['hammer_COM']
        if isinstance(hcom, np.ndarray) and hcom.ndim == 2 and hcom.shape[0] == 3:
            try:
                rep['hammer_COM_instants'] = {
                    'I1': hcom[:, I1], 'I2': hcom[:, I2], 'I3': hcom[:, I3], 'I4': hcom[:, I4], 'I5': [hcom[:, idx] for idx in ensure_list(I5)]
                }
            except Exception as e:
                print(f"‚ö†Ô∏è Problema con hammer_COM in {rep.get('filename', 'unknown')}: {e}")


    # Centro di massa dell‚Äôatleta (vettore 3D)
    if rep.get('athlete_COM') is not None:
        acom = rep['athlete_COM']
        if isinstance(acom, np.ndarray) and acom.ndim == 2 and acom.shape[0] == 3:
            try:
                rep['athlete_COM_instants'] = {
                     'I1': acom[:, I1], 'I2': acom[:, I2], 'I3': acom[:, I3], 'I4': acom[:, I4], 'I5': [acom[:, idx] for idx in ensure_list(I5)]
                 }
            except Exception as e:
                 print(f"‚ö†Ô∏è Problema con athlete_COM in {rep.get('filename', 'unknown')}: {e}")

    # Asse istantaneo di rotazione (vettore unitario 3D)
    if rep.get('axis_rotation') is not None:
        axis = rep['axis_rotation']
        if isinstance(axis, np.ndarray) and axis.ndim == 2 and axis.shape[0] == 3:
            try:
                rep['axis_rotation_instants'] = {
                      'I1': axis[:, I1], 'I2': axis[:, I2], 'I3': axis[:, I3], 'I4': axis[:, I4], 'I5': [axis[:, idx] for idx in ensure_list(I5)]
                  }
            except Exception as e:
                 print(f"‚ö†Ô∏è Problema con axis_rotation in {rep.get('filename', 'unknown')}: {e}")

    # Centro di massa combinato atleta-martello (vettore 3D)
    if rep.get('athlete_hammer_COM') is not None:
        combo = rep['athlete_hammer_COM']
        if isinstance(combo, np.ndarray) and combo.ndim == 2 and combo.shape[0] == 3:
            try:
                rep['athlete_hammer_COM_instants'] = {
                'I1': combo[:, I1], 'I2': combo[:, I2], 'I3': combo[:, I3], 'I4': combo[:, I4], 'I5': [combo[:, idx] for idx in ensure_list(I5)]
                }
            except Exception as e:
                print(f"‚ö†Ô∏è Problema con athlete_hammer_COM in {rep.get('filename', 'unknown')}: {e}")

# -----------------------------
# DATA ANALYSIS
# -----------------------------

import numpy as np

def rotate_xy(array_xyz):
    # array_xyz shape: (3, n_frames)
    R = np.array([[-1, 0],
                  [0, -1]])

    array_xy = R @ array_xyz[:2, :]
    array_rot = np.vstack([array_xy, array_xyz[2, :]])
    return array_rot


def compute_variables(DATA):
    for subj in DATA:
        for shoe in DATA[subj]:
            for trial in DATA[subj][shoe]:
                for rep in DATA[subj][shoe][trial].get("reps", []):
                    mkr = rep['mkr_cut']
                    names = rep['marker_names']
                    names_lower = [n.lower() for n in names]

                    # --- HAMMER centroid ---
                    try:
                        idxs = [names_lower.index(m) for m in ['hammer2', 'hammer3', 'hammer4']]
                        hammer_xyz = mkr[0:3, idxs, :]
                        hammer_centroid = np.mean(hammer_xyz, axis=1)
                        rep['HAMMER'] = hammer_centroid

                    except ValueError:
                        print(f"‚ö†Ô∏è HAMMER markers missing in: {rep['filename']}")
                        rep['HAMMER'] = None

                    # --- Global velocity (frame-to-frame) ---
                    if rep['HAMMER'] is not None:
                        hammer_center = rotate_xy(rep['HAMMER'])
                        hammer_vel_global = np.diff(hammer_center, axis=1, prepend=hammer_center[:, :1])
                        rep['hammer_vel_global'] = hammer_vel_global


                    else:
                        rep['hammer_vel_global'] = None

                    # --- Tangential velocity around subject COM ---
                    if 'centreofmass' in names_lower and rep['HAMMER'] is not None:
                        com_idx = names_lower.index('centreofmass')
                        com_xyz = mkr[0:3, com_idx, :]
                        radius = rotate_xy(rep['HAMMER']) - rotate_xy(com_xyz)
                        radius_norm = np.linalg.norm(radius, axis=0)
                        radius_norm[radius_norm == 0] = 1e-8
                        unit_radius = radius / radius_norm
                        proj = np.sum(rep['hammer_vel_global'] * unit_radius, axis=0)
                        tangential = rep['hammer_vel_global'] - unit_radius * proj
                        rep['hammer_vel_COM'] = tangential
                        # --- Additional Kinematics: Angular velocity, radius of rotation, centrifugal force, etc. ---

                        # Get marker names
                        marker_names = rep['marker_names']
                        markers = rep['mkr_cut']
                        names_lower = [n.lower() for n in marker_names]

                        # Marker indices
                        hammer_ids = [marker_names.index(m) for m in ['hammer1', 'hammer2', 'hammer3', 'hammer4']]
                        hip_ids = [marker_names.index(m) for m in ['LASI', 'RASI']]
                        shoulder_ids = [marker_names.index(m) for m in ['LSHO', 'RSHO']]
                        lfeet_ids = [marker_names.index(m) for m in ['LHEE', 'LTOE', 'LFMH', 'LVMH']]
                        rfeet_ids = [marker_names.index(m) for m in ['RHEE', 'RTOE', 'RFMH', 'RVMH']]

                        # Coordinates in meters     # (3, 4, n_frames)
                        hammer_markers = 1e-3 * markers[0:3, hammer_ids, :]
                        hips_markers = 1e-3 * markers[0:3, hip_ids, :]          # (3, 4, n_frames)
                        L_sho = rotate_xy(1e-3 * markers[0:3, shoulder_ids[0], :])          # (3, n_frames)
                        R_sho = rotate_xy(1e-3 * markers[0:3, shoulder_ids[1], :] )         # (3, n_frames)
                        L_feet = 1e-3 * markers[0:3, lfeet_ids, :]       # (3, 4, n_frames)
                        R_feet = 1e-3 * markers[0:3, rfeet_ids, :]    # (3, 4, n_frames)
                        L_feet_center = rotate_xy(np.mean(L_feet, axis=1) )               # (3, n_frames)
                        R_feet_center = rotate_xy(np.mean(R_feet, axis=1)  )              # (3, n_frames)
                        feet_center = 0.5 * (L_feet_center + R_feet_center)
                        hammer_com = rotate_xy(np.mean(hammer_markers, axis=1))             # (3, n_frames)
                        hips_com = rotate_xy(np.mean(hips_markers, axis=1) )                # (3, n_frames)
                        shoulder_center = 0.5 * (L_sho + R_sho)
                        athlete_center = (shoulder_center + hips_com + feet_center) / 3.0
                        radius_vectors = hammer_com - athlete_center          # (3, n_frames)

                        velocity_hammer = hammer_vel_global
                        #dt = 1 / 200  # sampling rate from file = 200 Hz
                        #velocity_hammer = np.gradient(hammer_com, dt, axis=1)   # (3, n_frames)

                        # Angular velocity
                        cross_rv = np.cross(radius_vectors.T, velocity_hammer.T)       # (n_frames, 3)
                        radius_norm_sq = np.sum(radius_vectors**2, axis=0)             # (n_frames,)
                        omega = (cross_rv.T / radius_norm_sq).T                        # (n_frames, 3)
                        omega_magnitude = np.linalg.norm(omega, axis=1, keepdims=True)
                        omega_unit = omega / omega_magnitude  # shape: (n_frames, 3)

                        # Centrifugal force
                        omega_cross_r = np.cross(omega, radius_vectors.T)              # (n_frames, 3)
                        gender = subject_info[subj]['gender']
                        hammer_mass = 7.26 if gender == 0 else 4.0
                        force_centrifugal = np.cross(omega, omega_cross_r) * hammer_mass  # (n_frames, 3)

                        # Athlete Hammer COM

                        athlete_hammer_com = hammer_com-hips_com

                        # Hips height

                        hips_height = hips_com[2, :]

                        # --- Angle hips-chest (in X-Y plane) ---
                        L_hip = rotate_xy(1e-3 * markers[0:3, hip_ids[0], :])          # (3, n_frames)
                        R_hip = rotate_xy(1e-3 * markers[0:3, hip_ids[1], :] )         # (3, n_frames)
                        hips_vector = R_hip - L_hip
                        chest_vector = R_sho - L_sho
                        hips_xy = np.squeeze(hips_vector).T[:, :2]
                        chest_xy = np.squeeze(chest_vector).T[:, :2]

                        hips_unit = hips_xy / (np.linalg.norm(hips_xy, axis=1, keepdims=True) + 1e-8)
                        chest_unit = chest_xy / (np.linalg.norm(chest_xy, axis=1, keepdims=True) + 1e-8)
                        dot_proj = np.einsum('ij,ij->i', hips_unit, chest_unit)
                        angle_deg_hipschest = np.degrees(np.arccos(np.clip(dot_proj, -1.0, 1.0)))


                        # Store results
                        rep['angular_velocity'] = omega.T                 # shape: (3, n_frames)
                        rep['radius_rotation'] = radius_vectors           # (3, n_frames)
                        rep['centrifugal_force'] = force_centrifugal.T    # (3, n_frames)
                        rep['hammer_COM'] = hammer_com                    # (3, n_frames)
                        rep['athlete_COM'] = hips_com                     # (3, n_frames)
                        rep['axis_rotationt'] = omega_unit                     # (3, n_frames)
                        rep['athlete_hammer_COM'] = athlete_hammer_com
                        rep['hips_height'] = hips_height
                        rep['hip_chest_angle_deg'] = angle_deg_hipschest

                    else:
                        rep['hammer_vel_COM'] = None
                        rep['angular_velocity'] = None
                        rep['radius_rotation'] = None
                        rep['centrifugal_force'] = None
                        rep['axis_rotation'] = None
                        rep['athlete_hammer_COM'] = None
                        rep['hammer_COM'] = None                   # (3, n_frames)
                        rep['athlete_COM'] = None                    # (3, n_frames)
                        rep['hip_chest_angle_deg'] = None

                    # --- Relative COM (weighted between subject and hammer) ---
                    if subj in subject_info and 'centreofmass' in names_lower and rep['HAMMER'] is not None:
                        m_sub = subject_info[subj]['mass']
                        gender = subject_info[subj]['gender']
                        m_hammer = 7.26 if gender == 0 else 4.0
                        com_xyz = rotate_xy(mkr[0:3, names_lower.index('centreofmass'), :])
                        rep['relativeCOM'] = (m_sub * com_xyz + m_hammer * rotate_xy(rep['HAMMER'])) / (m_sub + m_hammer)
                    else:
                        rep['relativeCOM'] = None

                    # --- Summary stats for tangential velocity ---
                    if rep['hammer_vel_COM'] is not None:
                        rep['hammer_vel_COM_mag'] = np.linalg.norm(rep['hammer_vel_COM'], axis=0)
                        rep['hammer_vel_COM_peak'] = np.max(rep['hammer_vel_COM_mag'])
                        rep['hammer_vel_COM_mean'] = np.mean(rep['hammer_vel_COM_mag'])
                        rep['angular_velocity_mag'] = np.linalg.norm(rep['angular_velocity'], axis=0)
                        rep['angular_velocity_peak'] = np.max(rep['angular_velocity_mag'])
                        rep['angular_velocity_mean'] = np.mean(rep['angular_velocity_mag'])
                    else:
                        rep['hammer_vel_COM_mag'] = None
                        rep['hammer_vel_COM_peak'] = None
                        rep['hammer_vel_COM_mean'] = None
                        rep['angular_velocity_mag'] = None
                        rep['angular_velocity_peak'] = None
                        rep['angular_velocity_mean'] = None

                    # --- Instants computation ---
                    compute_instants(rep)

                    compute_additional_variables(rep)

compute_variables(DATA_CUT)

#############################################
##
##  CSV EXPORT FUNCTION
##
#############################################

import csv

def export_variables_to_csv(DATA, output_file):
    rows = []

    for subj in DATA:
        for shoe in DATA[subj]:
            for trial in DATA[subj][shoe]:
                for rep_idx, rep in enumerate(DATA[subj][shoe][trial].get("reps", [])):
                    row = {
                        "subj": subj,
                        "shoe": shoe,
                        "trial": trial,
                        "rep": rep_idx + 1
                    }

                    # AMTI force values at instants
                    for platform in ["AMTI1", "AMTI2"]:
                        force_instants = rep.get(f"{platform}_force_instants")

                        if force_instants:
                            for inst, val in force_instants.items():
                                # if it's I5 and a sequence, take the last element
                                    if inst == "I5":
                                        val = val[-1]

                                # now continue as usual
                                    if hasattr(val, "__len__") and len(val) == 3:
                                        for axis, axis_name in enumerate(["x", "y", "z"]):
                                            key = f"{platform}_{inst}_{axis_name}"
                                            row[key] = val[axis]
                                    else:
                                        row[f"{platform}_{inst}"] = val

                    # Tangential velocity at instants
                    vel_instants = rep.get("hammer_vel_COM_instants")
                    if vel_instants:
                        for inst, val in vel_instants.items():
                            # if it's I5 and a sequence, take the last element
                            if inst == "I5":
                                val = val[-1]
                            for axis, axis_name in enumerate(["x", "y", "z"]):
                                key = f"vel_{inst}_{axis_name}"
                                row[key] = val[axis]

                    # Angular velocity at instants
                    omega_instants = rep.get("angular_velocity_instants")
                    if omega_instants:
                        for inst, val in omega_instants.items():
                            # if it's I5 and a sequence, take the last element
                            if inst == "I5":
                                val = val[-1]

                            for axis, axis_name in enumerate(["x", "y", "z"]):
                                key = f"omega_{inst}_{axis_name}"
                                row[key] = val[axis]

                    # Radius vector at instants
                    radius_instants = rep.get("radius_rotation_instants")
                    if radius_instants:
                        for inst, val in radius_instants.items():
                            for axis, axis_name in enumerate(["x", "y", "z"]):
                                key = f"radius_{inst}_{axis_name}"
                                row[key] = val[axis]

                    # Centrifugal force at instants
                    cf_instants = rep.get("centrifugal_force_instants")
                    if cf_instants:
                        for inst, val in cf_instants.items():
                            for axis, axis_name in enumerate(["x", "y", "z"]):
                                key = f"cf_{inst}_{axis_name}"
                                row[key] = val[axis]

                    # Left ankle plantar-dorsiflexion at instants
                    Lank_instants = rep.get("LAnkleAngles_instants")
                    if Lank_instants:
                        for inst, val in Lank_instants.items():
                            key = f"LANK_angle_{inst}"
                            row[key] = val

                    # Right ankle plantar-dorsiflexion at instants
                    Rank_instants = rep.get("RAnkleAngles_instants")
                    if Rank_instants:
                        for inst, val in Rank_instants.items():
                            key = f"RANK_angle_{inst}"
                            row[key] = val

                    # Hip‚Äìchest angle at instants
                    hipchest_instants = rep.get("hip_chest_angle_instants")
                    if hipchest_instants:
                        for inst, val in hipchest_instants.items():
                            key = f"hip_chest_angle_{inst}"
                            row[key] = val

                    rows.append(row)

    # Ora che rows √® popolato, deriviamo gli header
    base_fields = ["subj", "shoe", "trial", "rep"]
    all_keys = set()
    for r in rows:
        all_keys.update(r.keys())
    remaining_fields = sorted(k for k in all_keys if k not in base_fields)
    header = base_fields + remaining_fields

    with open(output_file, mode='w', newline='') as file:
        writer = csv.DictWriter(file, fieldnames=header)
        writer.writeheader()
        writer.writerows(rows)

    print(f"üìÑ Variabili esportate in: {output_file}")

#############################################################
##
##   Creazione di file .csv singoli per analisi del dato
##
#############################################################

subj = "SUB003"
shoe = "WA"
trial = "ferma_osc"
rep_idx = 1   # second rep ‚Üí index 1 (since Python is 0-based)

rep = DATA[subj][shoe][trial]["reps"][rep_idx]

#hammer = rep.get("hammer_vel_global_cut")
mkr = rep['mkr_cut']
names = rep['marker_names']

names_lower = [n.lower() for n in names]

# --- HAMMER centroid ---

#idxs = [names_lower.index(m) for m in ['hammer2', 'hammer3', 'hammer4']]
#hammer_xyz = mkr[0:3, idxs, :]
#hammer_centroid = np.mean(hammer_xyz, axis=1)
#hammer = hammer_centroid

RTOE_idx = names.index("RTOE")
hammer = mkr[:, RTOE_idx, :]


if hammer is not None:
    import csv

    output_file = os.path.join(base_dir, "pos_test.csv")

    with open(output_file, mode="w", newline="") as file:
        writer = csv.writer(file)
        writer.writerow(["frame", "x", "y", "z"])  # header
        for frame_idx in range(hammer.shape[1]):
            writer.writerow([
                frame_idx,
                hammer[0, frame_idx],
                hammer[1, frame_idx],
                hammer[2, frame_idx]
            ])

    print(f"‚úÖ Exported to: {output_file}")

csv_output_path = os.path.join(base_dir, "analisi_risultati_tip.csv")
export_variables_to_csv(DATA_CUT, csv_output_path)

import os
import numpy as np
import matplotlib.pyplot as plt

def ensure_list(x):
    """Wrap an int into a list, leave lists/arrays as list, otherwise return []."""
    if x is None:
        return []
    if isinstance(x, (list, tuple, np.ndarray)):
        return list(x)
    return [x]

def plot_hammer_trajectories(DATA_CUT, output_folder="figures/trajectories", invert_y=True):
    """
    Plot hammer trajectories (X vs Y) for each subject x shoe x trial x rep,
    overlaying instants (I1..I5). Uses rep.get('subject'/'shoe'/'trial') if present.
    """
    os.makedirs(output_folder, exist_ok=True)

    colors_shoes = {"WA": "tab:blue", "FF": "tab:red"}
    colors_instants = {"I1": "red", "I2": "gold", "I3": "limegreen", "I4": "dodgerblue", "I5": "mediumvioletred"}
    marker_styles = {"I1":"o", "I2":"s", "I3":"^", "I4":"v", "I5":"X"}

    for subj in DATA_CUT:
        for shoe in DATA_CUT[subj]:
            for trial in DATA_CUT[subj][shoe]:
                for rep_idx, rep in enumerate(DATA_CUT[subj][shoe][trial].get("reps", [])):
                    hammer = rep.get("HAMMER")  # expecting shape (3, n_frames)

                    # rotation matrix for XY plane
                    R = np.array([[-1, 0],
                                  [0, -1]])

                    # apply rotation only to X and Y
                    xy_rot = R @ hammer[:2, :]   # shape (2, n_frames)

                    # combine with Z (unchanged)
                    hammer = np.vstack([xy_rot, hammer[2, :]])  # shape still (3, n_frames)

                    instants = rep.get("instants", {})

                    # metadata from rep (with fallbacks)
                    subject = rep.get('subject', subj)
                    shoe_type = rep.get('shoe', shoe)
                    trial_name = rep.get('trial', trial)
                    rep_id = rep.get('rep_idx', rep_idx)

                    # sanity checks
                    if not isinstance(hammer, np.ndarray) or hammer.shape[0] < 2:
                        # skip invalid data
                        continue

                    x = hammer[0, :]
                    y = hammer[1, :]

                    # create figure
                    fig, ax = plt.subplots(figsize=(8, 6))
                    ax.plot(x, y, linewidth=1, alpha=0.6, label="Trajectory")
                    ax.scatter(x[0], y[0], marker='.', s=40, label='Start')   # start point
                    ax.scatter(x[-1], y[-1], marker='*', s=50, label='End')   # end point

                    # overlay instants (handle ints and lists, multiple I5)
                    for key, color in colors_instants.items():
                        vals = ensure_list(instants.get(key))
                        valid_idxs = [int(v) for v in vals if (isinstance(v, (int, np.integer)) or (isinstance(v, float) and v.is_integer())) and 0 <= int(v) < hammer.shape[1]]
                        if valid_idxs:
                            # plot all points for that instant (I5 can yield multiple starts)
                            ax.scatter(x[valid_idxs], y[valid_idxs],
                                       color=color, s=60, marker=marker_styles.get(key, "o"),
                                       label=key if key not in ("I5",) else f"{key} (all)")
                            # annotate with frame number (small offset)
                            for vi in valid_idxs:
                                ax.annotate(str(vi), (x[vi], y[vi]), textcoords="offset points", xytext=(4,4), fontsize=8)

                    # aesthetics & metadata box in corner
                    ax.set_xlabel("X")
                    ax.set_ylabel("Y")
                    ax.set_title(f"Hammer Trajectory ‚Äî Subject: {subject} | Shoe: {shoe_type} | Trial: {trial_name} | Rep: {rep_id + 1}")
                    ax.grid(True)

                    # compact metadata textbox (useful if title gets long)
                    meta_text = f"Subj: {subject}\nShoe: {shoe_type}\nTrial: {trial_name}\nRep: {rep_id + 1}"
                    ax.text(0.01, 0.99, meta_text, transform=ax.transAxes, va='top', ha='left',
                            bbox=dict(boxstyle="round,pad=0.3", alpha=0.25))

                    # legend: avoid duplicate labels
                    handles, labels = ax.get_legend_handles_labels()
                    by_label = dict(zip(labels, handles))
                    ax.legend(by_label.values(), by_label.keys(), loc="lower left", fontsize=8)

                    # save and close
                    safe_subject = str(subject).replace(" ", "_")
                    safe_shoe = str(shoe_type).replace(" ", "_")
                    safe_trial = str(trial_name).replace(" ", "_")
                    filename = f"traj_{safe_subject}_{safe_shoe}_{safe_trial}_rep{rep_id}.png"
                    filepath = os.path.join(output_folder, filename)
                    fig.tight_layout()
                    fig.savefig(filepath, dpi=300, bbox_inches="tight")
                    plt.show()
                    plt.close(fig)

plot_hammer_trajectories(DATA_CUT)

import os
import numpy as np
import matplotlib.pyplot as plt

def ensure_list(x):
    if x is None:
        return []
    if isinstance(x, (list, tuple, np.ndarray)):
        return list(x)
    return [x]

def plot_radius_vs_normalized_phase(DATA_CUT, output_folder="figures/radius_phase_norm", fps=100):
    """
    Plot radius of instantaneous rotation (X,Y,Z) vs normalized phase (0‚Äì100%).
    """
    os.makedirs(output_folder, exist_ok=True)

    colors_instants = {"I1": "red", "I2": "gold", "I3": "limegreen",
                       "I4": "dodgerblue", "I5": "mediumvioletred"}
    marker_styles = {"I1":"o", "I2":"s", "I3":"^", "I4":"v", "I5":"X"}
    comp_labels = ["X", "Y", "Z"]

    for subj in DATA_CUT:
        for shoe in DATA_CUT[subj]:
            for trial in DATA_CUT[subj][shoe]:
                for rep_idx, rep in enumerate(DATA_CUT[subj][shoe][trial].get("reps", [])):
                    radius = rep.get("radius_rotation")  # (3, n_frames)
                    instants = rep.get("instants", {})

                    if not isinstance(radius, np.ndarray) or radius.shape[0] != 3:
                        continue

                    n_frames = radius.shape[1]
                    phase = np.linspace(0, 100, n_frames)  # normalized phase 0‚Äì100%

                    # metadata
                    subject = rep.get('subject', subj)
                    shoe_type = rep.get('shoe', shoe)
                    trial_name = rep.get('trial', trial)
                    rep_id = rep.get('rep_idx', rep_idx)

                    for comp_idx, comp_name in enumerate(comp_labels):
                        y = radius[comp_idx, :]

                        fig, ax = plt.subplots(figsize=(8,6))
                        ax.plot(phase, y, linewidth=1.5, alpha=0.8, label=f"{comp_name} component")

                        # overlay instants
                        for key, color in colors_instants.items():
                            vals = ensure_list(instants.get(key))
                            valid_idxs = [int(v) for v in vals if isinstance(v, (int, np.integer))]
                            if valid_idxs:
                                phase_instant = [idx * 100 / n_frames for idx in valid_idxs]  # normalized phase
                                ax.scatter(phase_instant, y[valid_idxs],
                                                    color=color, s=60, marker=marker_styles.get(key, "o"),
                                                    label=key if key != "I5" else f"{key} (all)")
                                for pi, vi in zip(phase_instant, valid_idxs):
                                    ax.annotate(str(vi), (pi, y[vi]), textcoords="offset points", xytext=(4,4), fontsize=8)


                        # labels, title, grid
                        ax.set_xlabel("Phase (%)")
                        ax.set_ylabel(f"Radius {comp_name}")
                        ax.set_title(f"Radius vs Phase ‚Äî Subject: {subject} | Shoe: {shoe_type} | Trial: {trial_name} | Rep: {rep_id+1}")
                        ax.grid(True)

                        # metadata box
                        meta_text = f"Subj: {subject}\nShoe: {shoe_type}\nTrial: {trial_name}\nRep: {rep_id+1}"
                        ax.text(0.01, 0.99, meta_text, transform=ax.transAxes, va='top', ha='left',
                                bbox=dict(boxstyle="round,pad=0.3", alpha=0.25))

                        # clean legend
                        handles, labels = ax.get_legend_handles_labels()
                        by_label = dict(zip(labels, handles))
                        ax.legend(by_label.values(), by_label.keys(), loc="lower left", fontsize=8)

                        # save
                        safe_subject = str(subject).replace(" ", "_")
                        safe_shoe = str(shoe_type).replace(" ", "_")
                        safe_trial = str(trial_name).replace(" ", "_")
                        filename = f"radius_{comp_name}_{safe_subject}_{safe_shoe}_{safe_trial}_rep{rep_id}.png"
                        filepath = os.path.join(output_folder, filename)
                        fig.tight_layout()
                        fig.savefig(filepath, dpi=300, bbox_inches="tight")
                        plt.show()
                        plt.close(fig)

plot_radius_vs_normalized_phase(DATA_CUT)

import os
import numpy as np
import matplotlib.pyplot as plt

def ensure_list(x):
    if x is None:
        return []
    if isinstance(x, (list, tuple, np.ndarray)):
        return list(x)
    return [x]

def plot_angular_velocity_vs_normalized_phase(DATA_CUT, output_folder="figures/angular_velocity_phase_norm", fps=100):
    """
    Plot angular velocity (X,Y,Z) vs normalized phase (0‚Äì100%).
    """
    os.makedirs(output_folder, exist_ok=True)

    colors_instants = {"I1": "red", "I2": "gold", "I3": "limegreen",
                       "I4": "dodgerblue", "I5": "mediumvioletred"}
    marker_styles = {"I1":"o", "I2":"s", "I3":"^", "I4":"v", "I5":"X"}
    comp_labels = ["X", "Y", "Z"]

    for subj in DATA_CUT:
        for shoe in DATA_CUT[subj]:
            for trial in DATA_CUT[subj][shoe]:
                for rep_idx, rep in enumerate(DATA_CUT[subj][shoe][trial].get("reps", [])):
                    omega = rep.get("angular_velocity")  # (3, n_frames)
                    instants = rep.get("instants", {})

                    if not isinstance(omega, np.ndarray) or omega.shape[0] != 3:
                        continue

                    n_frames = omega.shape[1]
                    phase = np.linspace(0, 100, n_frames)  # normalized phase 0‚Äì100%

                    # metadata
                    subject = rep.get('subject', subj)
                    shoe_type = rep.get('shoe', shoe)
                    trial_name = rep.get('trial', trial)
                    rep_id = rep.get('rep_idx', rep_idx)

                    for comp_idx, comp_name in enumerate(comp_labels):
                        y = omega[comp_idx, :]

                        fig, ax = plt.subplots(figsize=(8,6))
                        ax.plot(phase, y, linewidth=1.5, alpha=0.8, label=f"{comp_name} component")

                        # overlay instants
                        for key, color in colors_instants.items():
                            vals = ensure_list(instants.get(key))
                            valid_idxs = [int(v) for v in vals if isinstance(v, (int, np.integer))]
                            if valid_idxs:
                                phase_instant = [idx * 100 / n_frames for idx in valid_idxs]  # normalized phase
                                ax.scatter(phase_instant, y[valid_idxs],
                                           color=color, s=60, marker=marker_styles.get(key, "o"),
                                           label=key if key != "I5" else f"{key} (all)")
                                for pi, vi in zip(phase_instant, valid_idxs):
                                    ax.annotate(str(vi), (pi, y[vi]), textcoords="offset points", xytext=(4,4), fontsize=8)

                        # labels, title, grid
                        ax.set_xlabel("Phase (%)")
                        ax.set_ylabel(f"Angular velocity {comp_name}")
                        ax.set_title(f"Angular Velocity vs Phase ‚Äî Subject: {subject} | Shoe: {shoe_type} | Trial: {trial_name} | Rep: {rep_id+1}")
                        ax.grid(True)

                        # metadata box
                        meta_text = f"Subj: {subject}\nShoe: {shoe_type}\nTrial: {trial_name}\nRep: {rep_id+1}"
                        ax.text(0.01, 0.99, meta_text, transform=ax.transAxes, va='top', ha='left',
                                bbox=dict(boxstyle="round,pad=0.3", alpha=0.25))

                        # clean legend
                        handles, labels = ax.get_legend_handles_labels()
                        by_label = dict(zip(labels, handles))
                        ax.legend(by_label.values(), by_label.keys(), loc="lower left", fontsize=8)

                        # save
                        safe_subject = str(subject).replace(" ", "_")
                        safe_shoe = str(shoe_type).replace(" ", "_")
                        safe_trial = str(trial_name).replace(" ", "_")
                        filename = f"angular_velocity_{comp_name}_{safe_subject}_{safe_shoe}_{safe_trial}_rep{rep_id}.png"
                        filepath = os.path.join(output_folder, filename)
                        fig.tight_layout()
                        fig.savefig(filepath, dpi=300, bbox_inches="tight")
                        plt.show()
                        plt.close(fig)

plot_angular_velocity_vs_normalized_phase(DATA_CUT)

import os
import numpy as np
import matplotlib.pyplot as plt

def ensure_list(x):
    if x is None:
        return []
    if isinstance(x, (list, tuple, np.ndarray)):
        return list(x)
    return [x]

def plot_tangential_velocity_vs_normalized_phase(DATA_CUT, output_folder="figures/tangential_velocity_phase_norm", fps=100):
    """
    Plot hammer tangential velocity (X,Y,Z) vs normalized phase (0‚Äì100%).
    """
    os.makedirs(output_folder, exist_ok=True)

    colors_instants = {"I1": "red", "I2": "gold", "I3": "limegreen",
                       "I4": "dodgerblue", "I5": "mediumvioletred"}
    marker_styles = {"I1":"o", "I2":"s", "I3":"^", "I4":"v", "I5":"X"}
    comp_labels = ["X", "Y", "Z"]

    for subj in DATA_CUT:
        for shoe in DATA_CUT[subj]:
            for trial in DATA_CUT[subj][shoe]:
                for rep_idx, rep in enumerate(DATA_CUT[subj][shoe][trial].get("reps", [])):
                    vel = rep.get("hammer_vel_COM")  # (3, n_frames)
                    instants = rep.get("instants", {})

                    if not isinstance(vel, np.ndarray) or vel.shape[0] != 3:
                        continue

                    n_frames = vel.shape[1]
                    phase = np.linspace(0, 100, n_frames)  # normalized phase 0‚Äì100%

                    # metadata
                    subject = rep.get('subject', subj)
                    shoe_type = rep.get('shoe', shoe)
                    trial_name = rep.get('trial', trial)
                    rep_id = rep.get('rep_idx', rep_idx)

                    for comp_idx, comp_name in enumerate(comp_labels):
                        y = vel[comp_idx, :]

                        fig, ax = plt.subplots(figsize=(8,6))
                        ax.plot(phase, y, linewidth=1.5, alpha=0.8, label=f"{comp_name} component")

                        # overlay instants
                        for key, color in colors_instants.items():
                            vals = ensure_list(instants.get(key))
                            valid_idxs = [int(v) for v in vals if isinstance(v, (int, np.integer))]
                            if valid_idxs:
                                phase_instant = [idx * 100 / n_frames for idx in valid_idxs]
                                ax.scatter(phase_instant, y[valid_idxs],
                                           color=color, s=60, marker=marker_styles.get(key, "o"),
                                           label=key if key != "I5" else f"{key} (all)")
                                for pi, vi in zip(phase_instant, valid_idxs):
                                    ax.annotate(str(vi), (pi, y[vi]), textcoords="offset points", xytext=(4,4), fontsize=8)

                        # labels, title, grid
                        ax.set_xlabel("Phase (%)")
                        ax.set_ylabel(f"Tangential velocity {comp_name}")
                        ax.set_title(f"Tangential Velocity vs Phase ‚Äî Subject: {subject} | Shoe: {shoe_type} | Trial: {trial_name} | Rep: {rep_id+1}")
                        ax.grid(True)

                        # metadata box
                        meta_text = f"Subj: {subject}\nShoe: {shoe_type}\nTrial: {trial_name}\nRep: {rep_id+1}"
                        ax.text(0.01, 0.99, meta_text, transform=ax.transAxes, va='top', ha='left',
                                bbox=dict(boxstyle="round,pad=0.3", alpha=0.25))

                        # clean legend
                        handles, labels = ax.get_legend_handles_labels()
                        by_label = dict(zip(labels, handles))
                        ax.legend(by_label.values(), by_label.keys(), loc="lower left", fontsize=8)

                        # save
                        safe_subject = str(subject).replace(" ", "_")
                        safe_shoe = str(shoe_type).replace(" ", "_")
                        safe_trial = str(trial_name).replace(" ", "_")
                        filename = f"tangential_velocity_{comp_name}_{safe_subject}_{safe_shoe}_{safe_trial}_rep{rep_id}.png"
                        filepath = os.path.join(output_folder, filename)
                        fig.tight_layout()
                        fig.savefig(filepath, dpi=300, bbox_inches="tight")
                        plt.show()
                        plt.close(fig)

plot_tangential_velocity_vs_normalized_phase(DATA_CUT)

import os
import numpy as np
import matplotlib.pyplot as plt

def ensure_list(x):
    if x is None:
        return []
    if isinstance(x, (list, tuple, np.ndarray)):
        return list(x)
    return [x]

def plot_hip_chest_angle_vs_normalized_phase(DATA_CUT, output_folder="figures/hip_chest_angle_phase_norm", fps=100):
    """
    Plot hip-to-chest angle (degrees) vs normalized phase (0‚Äì100%).
    """
    os.makedirs(output_folder, exist_ok=True)

    colors_instants = {"I1": "red", "I2": "gold", "I3": "limegreen",
                       "I4": "dodgerblue", "I5": "mediumvioletred"}
    marker_styles = {"I1":"o", "I2":"s", "I3":"^", "I4":"v", "I5":"X"}

    for subj in DATA_CUT:
        for shoe in DATA_CUT[subj]:
            for trial in DATA_CUT[subj][shoe]:
                for rep_idx, rep in enumerate(DATA_CUT[subj][shoe][trial].get("reps", [])):
                    angle = rep.get("hip_chest_angle_deg")  # shape (1, n_frames) or (n_frames,)
                    instants = rep.get("instants", {})

                    if angle is None:
                        continue
                    angle = np.array(angle).flatten()  # ensure 1D
                    n_frames = angle.shape[0]
                    phase = np.linspace(0, 100, n_frames)  # normalized phase 0‚Äì100%

                    # metadata
                    subject = rep.get('subject', subj)
                    shoe_type = rep.get('shoe', shoe)
                    trial_name = rep.get('trial', trial)
                    rep_id = rep.get('rep_idx', rep_idx)

                    fig, ax = plt.subplots(figsize=(8,6))
                    ax.plot(phase, angle, linewidth=1.5, alpha=0.8, label="Hip-Chest Angle")

                    # overlay instants
                    for key, color in colors_instants.items():
                        vals = ensure_list(instants.get(key))
                        valid_idxs = [int(v) for v in vals if isinstance(v, (int, np.integer))]
                        if valid_idxs:
                            phase_instant = [idx * 100 / n_frames for idx in valid_idxs]
                            ax.scatter(phase_instant, angle[valid_idxs],
                                       color=color, s=60, marker=marker_styles.get(key, "o"),
                                       label=key if key != "I5" else f"{key} (all)")
                            for pi, vi in zip(phase_instant, valid_idxs):
                                ax.annotate(str(vi), (pi, angle[vi]), textcoords="offset points", xytext=(4,4), fontsize=8)

                    # labels, title, grid
                    ax.set_xlabel("Phase (%)")
                    ax.set_ylabel("Hip-Chest Angle (deg)")
                    ax.set_title(f"Hip-Chest Angle vs Phase ‚Äî Subject: {subject} | Shoe: {shoe_type} | Trial: {trial_name} | Rep: {rep_id+1}")
                    ax.grid(True)

                    # metadata box
                    meta_text = f"Subj: {subject}\nShoe: {shoe_type}\nTrial: {trial_name}\nRep: {rep_id+1}"
                    ax.text(0.01, 0.99, meta_text, transform=ax.transAxes, va='top', ha='left',
                            bbox=dict(boxstyle="round,pad=0.3", alpha=0.25))

                    # clean legend
                    handles, labels = ax.get_legend_handles_labels()
                    by_label = dict(zip(labels, handles))
                    ax.legend(by_label.values(), by_label.keys(), loc="lower left", fontsize=8)

                    # save
                    safe_subject = str(subject).replace(" ", "_")
                    safe_shoe = str(shoe_type).replace(" ", "_")
                    safe_trial = str(trial_name).replace(" ", "_")
                    filename = f"hip_chest_angle_{safe_subject}_{safe_shoe}_{safe_trial}_rep{rep_id}.png"
                    filepath = os.path.join(output_folder, filename)
                    fig.tight_layout()
                    fig.savefig(filepath, dpi=300, bbox_inches="tight")
                    plt.show()
                    plt.close(fig)

plot_hip_chest_angle_vs_normalized_phase(DATA_CUT)
